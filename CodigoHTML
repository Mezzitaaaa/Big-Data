/**
 * ========================================
 * Clasificador de Imágenes con Teachable Machine
 * ========================================
 * 
 * Este archivo contiene toda la lógica para:
 * 1. Cargar un modelo de Teachable Machine.
 * 2. Configurar y mostrar la webcam.
 * 3. Realizar predicciones en tiempo real.
 * 4. Actualizar la interfaz con los resultados.
 */

// URL del modelo proporcionada por Teachable Machine
const URL = "https://teachablemachine.withgoogle.com/models/TuUTZBEL4/";

// Variables globales para el modelo, webcam y predicciones
let model, webcam, labelContainer, maxPredictions;
let isRunning = false;

/**
 * Función principal para inicializar el modelo y la webcam.
 * Se ejecuta cuando se presiona el botón "Iniciar".
 */
async function init() {
    try {
        // Deshabilitar el botón de inicio y mostrar mensaje de carga
        const startBtn = document.getElementById('startButton');
        startBtn.disabled = true;
        startBtn.textContent = 'Cargando Modelo...';
        
        // URLs para el modelo y los metadatos
        const modelURL = URL + "model.json";
        const metadataURL = URL + "metadata.json";

        // Cargar el modelo y los metadatos de forma asíncrona
        model = await tmImage.load(modelURL, metadataURL);
        maxPredictions = model.getTotalClasses();

        // Configurar la webcam
        const flip = true; // Voltear la imagen horizontalmente (espejo)
        webcam = new tmImage.Webcam(400, 400, flip); // ancho, alto, voltear
        await webcam.setup(); // Solicitar acceso a la webcam
        await webcam.play();
        window.requestAnimationFrame(loop); // Iniciar el bucle de animación

        // Añadir el canvas de la webcam al contenedor HTML
        const webcamContainer = document.getElementById("webcam-container");
        webcamContainer.appendChild(webcam.canvas);
        
        // Preparar el contenedor de etiquetas para mostrar los resultados
        setupLabelContainer();
        
        // Habilitar el botón de detención
        document.getElementById('stopButton').disabled = false;
        isRunning = true;
    } catch (error) {
        console.error("Error al cargar el modelo:", error);
        
        // En caso de error, mostrar un mensaje en la interfaz
        const startBtn = document.getElementById('startButton');
        startBtn.textContent = 'Error al Cargar';
        startBtn.disabled = false;
        
        const labelContainer = document.getElementById("label-container");
        labelContainer.innerHTML = `<div class="error-message">Error: No se pudo cargar el modelo. Verifique la URL o su conexión a internet.</div>`;
    }
}

/**
 * Función para configurar el contenedor de etiquetas.
 * Crea dinámicamente los elementos HTML para mostrar cada predicción.
 */
function setupLabelContainer() {
    labelContainer = document.getElementById("label-container");
    labelContainer.innerHTML = ""; // Limpiar resultados anteriores
    
    for (let i = 0; i < maxPredictions; i++) {
        // Crear un contenedor para cada predicción
        const predictionDiv = document.createElement("div");
        predictionDiv.className = "prediction-item";

        // Etiqueta para el nombre de la clase
        const labelSpan = document.createElement("span");
        labelSpan.className = "prediction-label";
        
        // Etiqueta para el valor de la probabilidad
        const valueSpan = document.createElement("span");
        valueSpan.className = "prediction-value";

        // Añadir las etiquetas al contenedor
        predictionDiv.appendChild(labelSpan);
        predictionDiv.appendChild(valueSpan);

        // Crear la barra de progreso
        const progressBarContainer = document.createElement("div");
        progressBarContainer.className = "progress-bar-container";
        const progressBar = document.createElement("div");
        progressBar.className = "progress-bar";
        progressBarContainer.appendChild(progressBar);
        
        predictionDiv.appendChild(progressBarContainer);
        labelContainer.appendChild(predictionDiv);
    }
}

/**
 * Bucle de animación para actualizar la webcam y realizar predicciones.
 */
async function loop() {
    if (!isRunning) return;
    
    webcam.update(); // Actualizar el frame de la webcam
    await predict(); // Realizar una predicción
    window.requestAnimationFrame(loop); // Programar el siguiente frame
}

/**
 * Función para realizar una predicción con el modelo.
 */
async function predict() {
    // Realizar la predicción con el canvas de la webcam
    const prediction = await model.predict(webcam.canvas);
    
    // Actualizar la interfaz con los resultados de la predicción
    for (let i = 0; i < maxPredictions; i++) {
        const className = prediction[i].className;
        const probability = prediction[i].probability;
        
        // Obtener los elementos HTML para esta predicción
        const predictionItems = document.getElementsByClassName("prediction-item");
        const labelSpan = predictionItems[i].getElementsByClassName("prediction-label")[0];
        const valueSpan = predictionItems[i].getElementsByClassName("prediction-value")[0];
        const progressBar = predictionItems[i].getElementsByClassName("progress-bar")[0];

        // Actualizar el contenido de los elementos
        labelSpan.innerHTML = className;
        valueSpan.innerHTML = `${(probability * 100).toFixed(1)}%`;
        progressBar.style.width = `${probability * 100}%`;
    }
}

/**
 * Función para detener la clasificación.
 * Detiene la webcam y restablece la interfaz.
 */
function stop() {
    isRunning = false;
    if (webcam) {
        webcam.stop();
        document.getElementById("webcam-container").innerHTML = "";
    }
    document.getElementById('startButton').disabled = false;
    document.getElementById('startButton').textContent = 'Iniciar';
    document.getElementById('stopButton').disabled = true;
}
